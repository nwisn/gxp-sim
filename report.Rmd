---
title: "Simulation of Batched, Modular, Differentially Expressed Gene Microarrays using a Standard Multivariate Normal"
author: "Nick Wisniewski"
date: "June 14, 2018"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: 
      collapsed: false
      smooth_scroll: true
    number_sections: false
    theme: journal
    code_folding: hide
    df_print: paged
    
---

<style>
#nav_logo {
width: 100%;
margin-top: 40px;
}
</style>


# Introduction
We set out to simulate gene expression arrays, in order to later investigate the effects of various biases on methods like clustering and PCA. Typical benchmarking or validation studies seek to generate "realistic" models of gene expression data, by simulating Michaelis-Mentin kinetics etc. (e.g. see the DREAM challenges). However, these simulations are much too sophisticated for our purposes, and their complexity may actually obfuscate some of the simple biases we would like to investigate. In contrast, we focused on creating a simple and understandable generative model that incorporates only the following idealized features:

- mean expression levels (each gene has its own expression level and variance, and we can control the distribution of each)
- sample "read coverage" or similar (each sample has its own mean expression level and variance, and we can control the distribution)
- differential expression (mean differences between treatment groups)
- gene coexpression (modular structure)
- sample correlation (batch structure, treatment structure)

We especially note that the last bullet point concerning sample correlation often goes underappreciated. It is typically assumed that samples are independent. But correlation between samples reduces the effective sample size, while also inducing correlation between genes -- both important details when using gene networks for statistical inference. For more details on this topic, see [Efron (2009)](https://projecteuclid.org/euclid.aoas/1254773272).

Below, we design a generative model for the purpose of investigating these features on gene network inference. In the first part, we explain how to manipulate random samples from a normal distribution to exhibit all of the above features. In the second part, we implement the model in R and demonstrate how it works.









# Generative model
If we want to simulate $m$ correlated genes, it is sufficient to draw an $m$-vector sample $\boldsymbol{x}$ from an $m$-variate Gaussian distribution

$$\boldsymbol{x}\sim N(\boldsymbol{\mu}, \boldsymbol{\Sigma}) $$

where the (true) mean expression level of each gene $i\in{1,...,m}$ is specified by $\mu_i$, and the (true) covariance between genes $i$ and $j$ is specified by $\Sigma_{ij}$. 

In practice, these draws are computed by starting with a random $m$-vector from the standard (uncorrelated) $m$-variate Gaussian distribution

$$\boldsymbol{x}_0 \sim N(\boldsymbol 0, \boldsymbol I) $$
 and transforming the results by using the [Cholesky decomposition](https://en.wikipedia.org/wiki/Cholesky_decomposition) to introduce the desired covariance. This works as follows.
 
## Cholesky decomposition

The Cholesky decomposition takes a Hermitian $(\boldsymbol \Sigma = \boldsymbol \Sigma^{\dagger})$ positive definite (eigenvalues $\lambda \gt 0$) matrix into the product of a lower triangular matrix $\boldsymbol S$ and its conjugate transpose $\boldsymbol S^{\dagger}$,

$$ \boldsymbol \Sigma = \boldsymbol S \boldsymbol S^{\dagger}$$

The decomposed matrices $\boldsymbol S$ and $\boldsymbol S^{\dagger}$ are group operators that map one element to another by left multiplication

$$ \boldsymbol S \boldsymbol S_0 \rightarrow \boldsymbol S_1$$

which leads to the following transformation rule for the covariance 

$$ \boldsymbol S \boldsymbol \Sigma_0 \boldsymbol S^{\dagger} \rightarrow \boldsymbol \Sigma_1$$

It is also possible to directly transform the zero-mean uncorrelated data $\boldsymbol  x_0$ into correlated data $\boldsymbol x$ with mean $\boldsymbol \mu$

$$ \boldsymbol x_1 = \boldsymbol S \boldsymbol x_0 + \boldsymbol \mu $$
Here, $\boldsymbol \mu$ represents a sum of factors, such as the mean gene expression level, read coverage, etc. Next, we will show how these factors break out, and how more complex features can be modeled.

## Covariance structures

Suppose we draw $j\in{1, ..., n}$ i.i.d. samples from the $m$-variate Gaussian distribution

$$\boldsymbol{x}\sim N(\boldsymbol{\mu}, \boldsymbol{\Sigma}) $$
in order to get a data matrix, $\boldsymbol X= \boldsymbol x_j = x_{ij}$, where rows are genes and columns are samples. We also view this data as generated by a *matrix normal* distribution

$$ \underset{m\times n}{\boldsymbol X_{g\otimes s}} = N_{m,n}(\underset{m}{\boldsymbol \mu_g} \otimes \underset{n}{\boldsymbol \mu_s}, \underset{m\times m}{\boldsymbol\Sigma_g} \otimes \underset{n\times n}{\boldsymbol\Sigma_s})$$
where we distinguish between the mean gene expression $\boldsymbol \mu_g$ and the mean sample level $\boldsymbol \mu_s$; the sample covariance $\boldsymbol\Sigma_s$ and the gene covariance $\boldsymbol\Sigma_g$. In our method, because our samples were i.i.d., $\boldsymbol\Sigma_s = \boldsymbol 1$.

To arrive at final data, again we must start with data generated from the standard form 

$$ \underset{m\times n}{\boldsymbol X_{0}} = N_{m,n}(\underset{m}{\boldsymbol 0_g} \otimes \underset{n}{\boldsymbol 0_s}, \underset{m\times m}{\boldsymbol 1_g} \otimes \underset{n\times n}{\boldsymbol 1_s})$$

and create the necessary covariance using the appropriate Cholesky factors,  $\boldsymbol \Sigma_g=\boldsymbol S_g \boldsymbol S_g^{\dagger}$ and $\boldsymbol \Sigma_s=\boldsymbol S_s \boldsymbol S_s^{\dagger}$

$$ \boldsymbol X_{g \otimes s} = \boldsymbol S_g \boldsymbol X_{0} \boldsymbol S_s^{\dagger} + \boldsymbol \mu_g \otimes \boldsymbol \mu_s $$

### Modules
We simulate a modular structure by specifying the covariance $\boldsymbol\Sigma_g$ such that genes $i,j\in M$ in a module $M$ have high correlation, 

$$\Sigma^g_{ij}=\rho_{ij} \sigma_{i}\sigma_{j}, \,\,\,\,\, i,j\in M $$

For simplicity, we let $\sigma_i \rightarrow 1$, $\sigma_j \rightarrow 1$, and let each element of the covariance submatrix for a module have the same correlation coefficient, $\rho_{ij} = \rho_M$. Thus,

$$\Sigma^g_{ij}=\rho_M, \,\,\,\,\, i,j\in M $$

### Batches
We simulate a batch structure by specifying the covariance $\boldsymbol\Sigma_s$ such that samples $i,j\in B$ in a batch $B$ have high correlation, 

$$\Sigma^s_{ij}=\rho_{ij} \sigma_{i}\sigma_{j}, \,\,\,\,\, i,j\in B $$

For simplicity, we let $\sigma_i \rightarrow 1$, and let each element of the covariance submatrix for a batch have the same correlation coefficient, $\rho_{ij} = \rho_B$. Thus,

$$\Sigma^s_{ij}=\rho_B, \,\,\,\,\, i,j\in B $$

## Mean structures 

We now add corrections to the model based on mean shifts rather than covariance structure. The corrections we consider below are split into 3 kinds: 1) differential expression, 2) expression levels in modules, 3) read coverage in batches and treatment groups.

### Differential expression
We add differential expression by encoding them in the mean expression levels $\boldsymbol \mu_M \otimes \boldsymbol \mu_T$ of genes in modules $M$, across samples in treatment groups $T$. 


### Expression levels in modules

It is possible that genes in certain modules are more highly expressed than genes in other modules, regardless of any sample group. We can add that explicitly as another term $\boldsymbol \mu'_M \otimes \boldsymbol 1$.


### Read coverage in batches and treatments

It is possible that the read coverage of samples is different between treatment groups or batches -- for example, samples from sick patients or mistreated batches may have lower read coverage on average. We can explicitly include these terms, $\boldsymbol 1 \otimes \boldsymbol \mu'_T +  \boldsymbol 1 \otimes \boldsymbol \mu'_B$.

## Full model

When all of the above contributions are summed, the full model looks like

$$ \boldsymbol X_{g \otimes s} = \boldsymbol S_g \boldsymbol X_{0} \boldsymbol S_s^{\dagger} + ( \boldsymbol \mu_g \otimes \boldsymbol \mu_s ) + (\boldsymbol \mu_M \otimes \boldsymbol \mu_T) + ( \boldsymbol \mu'_M \otimes \boldsymbol 1) + (\boldsymbol 1 \otimes \boldsymbol \mu'_T) + (\boldsymbol 1 \otimes \boldsymbol \mu_B) $$

Finally, we standardized each contributing term into a Z-score by centering and scaling by the standard deviation, 


$$z_{ij}=\frac{\mu_{ij} - \frac{1}{nm} \sum_{ij} \mu_{ij} } {\sqrt{\sum_{ij}\frac{(\mu_{ij}-\frac{1}{nm}\sum_{ij}\mu_{ij})^2}{nm-1}}}$$

and introduced a set of weights $w_i\gt0$, so that they can be blended together more naturally,


$$ \boldsymbol X_{g \otimes s} = \boldsymbol S_g \boldsymbol X_{0} \boldsymbol S_s^{\dagger} + w_{gs}( \boldsymbol z_g \otimes \boldsymbol z_s ) + w_{MT}(\boldsymbol z_M \otimes \boldsymbol z_T) + w_M( \boldsymbol z'_M \otimes \boldsymbol 1) + w_T(\boldsymbol 1 \otimes \boldsymbol z'_T) + w_B(\boldsymbol 1 \otimes \boldsymbol z_B) $$

# Code

## Libraries

```{r libraries}
require(reshape2, quietly = T)
require(MASS, quietly = T)
require(ggplot2, quietly = T)
require(ggbiplot, quietly = T)
require(pheatmap, quietly = T)
require(RColorBrewer, quietly = T)
```

## Generate $X_0$ from a standard multivariate normal

```{r X0}
# how many genes, samples?
ngenes = 20
nsamples = 50

# generate data
set.seed(137)
X0 <- t(mvrnorm(n = nsamples,
                mu = rep(0, ngenes),
                Sigma = diag(rep(1, ngenes))))
rownames(X0) <- paste0("gene_", 1:ngenes)
colnames(X0) <- paste0("sample_", 1:nsamples)

scale.efron <- function(X, niter = 10){
    for(i in 1:niter){
        XT <- t(scale(X))
        X <- t(scale(XT))
    }
    return(X[1:nrow(X), 1:ncol(X)])
}

X0 <- scale.efron(X0, niter = 50)
```

## Specify mean-effect structures

### Assign genes to modules, and samples to batches and treatment groups

```{r modulebatch}
# ______________________________________________
# set modules, batches, etc

# specify the true modules
modules <- list("module A" = 1:round(ngenes/4),
                "module B" = (round(ngenes/4)+1):round(2*ngenes/4),
                "module C" = (round(2*ngenes/4)+1):round(3*ngenes/4))
# gather the rest into an unclustered module
module.singletons <- which(!1:ngenes %in% unlist(modules))
if(length(module.singletons>0)) modules[["singleton"]] <- which(!1:ngenes %in% unlist(modules))

# specify the sample batches
batches <- list("batch A" = 1:round(nsamples/3),
                "batch B" = (round(nsamples/3)+1):round(2*nsamples/3),
                "batch C" = (round(2*nsamples/3)+1):round(3*nsamples/3))
# gather the rest into singleton batches
batch.singletons <- which(!1:nsamples %in% unlist(batches))
if(length(batch.singletons)>0) batches[["singleton"]] <- which(!1:nsamples %in% unlist(batches))

# specify case/control samples
groups <- list("case" = 1:round(nsamples/2),
               "control" = (round(nsamples/2)+1):nsamples)

```

### Specify average expression level $\boldsymbol \mu_g$ and read coverage $\boldsymbol \mu_s$



```{r marginals}
# add marginal mean shifts for genes and samples
means.genes <-qnorm(seq(0.16, 0.84, length.out = ngenes), mean = 0, sd = 1) # gaussian distribution for now
means.samples <- qnorm(seq(0.16, 0.84, length.out = nsamples), mean = 0, sd = 1) # gaussian distribution for now
means.outerprod <- outer(means.genes, means.samples)
z.outer <- (means.outerprod-mean(means.outerprod))/sd(unlist(means.outerprod))
rownames(z.outer) <- paste0("gene_", 1:ngenes)
colnames(z.outer) <-  paste0("sample_", 1:nsamples)
```

### Specify the means of treatment groups, batches, and modules

```{r marginalgroups}
# initialize matrices
means.modules_groups <- means.modules <- means.groups <- means.batches <- matrix(0, nrow = nrow(X0), ncol = ncol(X0))

# adjust group means
means.groups.list <- list("case" = 0, "control" = -1)
for(ii in 1:length(means.groups.list)){
    this_group_name <- names(means.groups.list)[ii]
    this_group <- groups[[this_group_name]]
    means.groups[,this_group] <- means.groups[,this_group] + means.groups.list[[this_group_name]]
}
z.groups <- (means.groups - mean(means.groups))/sd(means.groups)

# adjust batch means
means.batches.list <- list("batch A" = 1, "batch B" = 0, "batch C" = 0)
for(ii in 1:length(means.batches.list)){
    this_batch_name <- names(means.batches.list)[ii]
    this_batch <- batches[[this_batch_name]]
    means.batches[,this_batch] <- means.batches[,this_batch] + means.batches.list[[this_batch_name]]
}
z.batches <- (means.batches - mean(means.batches))/sd(means.batches)

# adjust module means
means.modules.list <- list("module A" = 1, "module B" = 0, "module C" = 0, "singleton" = -1)
for(ii in 1:length(means.modules.list)){
    this_module_name <- names(means.modules.list)[ii]
    this_module <- modules[[this_module_name]]
    means.modules[this_module,] <- means.modules[this_module,] + means.modules.list[[this_module_name]]
}
z.modules <- (means.modules - mean(means.modules))/sd(means.modules)
```

### Specify differential expression

```{r dex}
# adjust means.modules_groups
means.modules_groups.list <- list(data.frame(module = "module A",
                                             group = "case",
                                             shift = 1),
                                  data.frame(module = "module B",
                                             group = "case",
                                             shift = -1),
                                  data.frame(module = "module C",
                                             group = "case",
                                             shift = 0))
for(ii in 1:length(means.modules_groups.list)){
    this_module_name <- means.modules_groups.list[[ii]][["module"]]
    this_group_name <-  means.modules_groups.list[[ii]][["group"]]
    this_shift <- means.modules_groups.list[[ii]][["shift"]]
    this_module <- modules[[as.character(this_module_name)]]
    this_group <- groups[[as.character(this_group_name)]]
    means.modules_groups[this_module, this_group] <- means.modules_groups[this_module, this_group] + this_shift
}
z.modules_groups <- (means.modules_groups - mean(means.modules_groups))/sd(means.modules_groups)
```


## Visualize the mean-effects


```{r annotations}
# gene annotations
module.gene.df <- data.frame(module = unlist(lapply(1:length(modules),
                                                    function(i) rep(names(modules)[i], length(modules[[i]])))),
                             gene = as.numeric(unlist(modules)),
                             row.names = paste0("gene_",as.numeric(unlist(modules))))


# sample annotations
batch.sample.df <- data.frame(batch = unlist(lapply(1:length(batches),
                                                    function(i) rep(names(batches)[i], length(batches[[i]])))),
                              sample = as.numeric(unlist(batches)),
                              row.names = paste0("batch_",as.numeric(unlist(batches))))

group.sample.df <- data.frame(group = unlist(lapply(1:length(groups),
                                                    function(i) rep(names(groups)[i], length(groups[[i]])))),
                              sample = as.numeric(unlist(groups)),
                              row.names = paste0("group_",as.numeric(unlist(groups))))

merged.sample.df.0 <- merge(batch.sample.df, group.sample.df)
merged.sample.df <- merged.sample.df.0[order(merged.sample.df.0$sample),]
rownames(merged.sample.df) <- colnames(z.outer)

rownames(z.batches) <- rownames(z.groups) <- rownames(z.modules) <- rownames(z.modules_groups) <- rownames(z.outer)
colnames(z.batches) <- colnames(z.groups) <- colnames(z.modules) <- colnames(z.modules_groups) <- colnames(z.outer)
```


```{r pheatmap}
# visualize these blocks
A <- z.outer
pheatmap(A,
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(A)), 0 - 0.01, length.out = 50),
                    seq(0, max(abs(A)), length.out = 50)),
         cluster_rows = F,
         cluster_cols = F,
         show_rownames = F,
         show_colnames = F,
         border_color = NA,
         annotation_row = module.gene.df,
         annotation_col = merged.sample.df,
         main = "Expression Levels Due to Outer Product")

A <- z.batches
pheatmap(A,
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(A)), 0 - 0.01, length.out = 50),
                    seq(0, max(abs(A)), length.out = 50)),
         cluster_rows = F,
         cluster_cols = F,
         show_rownames = F,
         show_colnames = F,
         border_color = NA,
         annotation_row = module.gene.df,
         annotation_col = merged.sample.df,
         main = "Expression Levels shifted by Batch")

A <- z.groups
pheatmap(A,
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(A)), 0 - 0.01, length.out = 50),
                    seq(0, max(abs(A)), length.out = 50)),
         cluster_rows = F,
         cluster_cols = F,
         show_rownames = F,
         show_colnames = F,
         border_color = NA,
         annotation_row = module.gene.df,
         annotation_col = merged.sample.df,
         main = "Expression Levels shifted by Treatment")

A <- z.modules
pheatmap(A,
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(A)), 0 - 0.01, length.out = 50),
                    seq(0, max(abs(A)), length.out = 50)),
         cluster_rows = F,
         cluster_cols = F,
         show_rownames = F,
         show_colnames = F,
         border_color = NA,
         annotation_row = module.gene.df,
         annotation_col = merged.sample.df,
         main = "Expression Levels shifted by Modules")

A <- z.modules_groups
pheatmap(A,
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(A)), 0 - 0.01, length.out = 50),
                    seq(0, max(abs(A)), length.out = 50)),
         cluster_rows = F,
         cluster_cols = F,
         show_rownames = F,
         show_colnames = F,
         border_color = NA,
         annotation_row = module.gene.df,
         annotation_col = merged.sample.df,
         main = "Expression Levels shifted by differential expression")

A <- z.outer + z.batches + z.groups + z.modules + z.modules_groups
pheatmap(A,
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(A)), 0 - 0.01, length.out = 50),
                    seq(0, max(abs(A)), length.out = 50)),
         cluster_rows = F,
         cluster_cols = F,
         show_rownames = F,
         show_colnames = F,
         border_color = NA,
         annotation_row = module.gene.df,
         annotation_col = merged.sample.df,
         main = "Expression Levels shifted by sum")
```

## Specify covariance structures

### Add covariance for modules and batches

```{r initialize_covariance}
#____________________________________
# covariance stuff

# target covariance matrices
Sigma.genes <- diag(rep(1,ngenes))
Sigma.samples <- diag(rep(1,nsamples))

cor.intramodules <- list("module A" = 0.7,
                         "module B" = 0.7,
                         "module C" = 0.7,
                         "singletons" = 0)
for(ii in names(cor.intramodules)){
    this_module <- modules[[ii]]
    rho <- cor.intramodules[[ii]]
    edgecor <- matrix(rho, nrow = length(this_module), ncol = length(this_module)) - diag(rep(rho, length(this_module)))
    Sigma.genes[this_module, this_module] <- Sigma.genes[this_module, this_module] + edgecor
}

cor.intrabatch <- list("batch A" = .6,
                       "batch B" = .6,
                       "batch C" = .6)
for(ii in names(cor.intrabatch)){
    this_batch <- batches[[ii]]
    rho <- cor.intrabatch[[ii]]
    edgecor <- matrix(rho, nrow = length(this_batch), ncol = length(this_batch)) - diag(rep(rho, length(this_batch)))
    Sigma.samples[this_batch, this_batch] <- Sigma.samples[this_batch, this_batch] + edgecor
}


```



```{r cholesky}
# cholesky factor
S.genes <- t(chol(Sigma.genes))
S.samples <- t(chol(Sigma.samples))

Xg <- S.genes %*% X0
Xs <- X0 %*% t(S.samples)
Xgs <- S.genes %*% X0 %*% t(S.samples)


rownames(Xg) <- rownames(Xs) <- rownames(Xgs) <- rownames(X0)
colnames(Xg) <- colnames(Xs) <- colnames(Xgs) <- colnames(X0)
```

## Visualize covariance structures


```{r figures}
A <- scale.efron(Xgs, 50)
pheatmap(A,
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(A)), 0 - 0.01, length.out = 50),
                   seq(0, max(abs(A)), length.out = 50)),
         cluster_rows = T,
         cluster_cols = T,
         scale = "none",
         annotation_row = module.gene.df,
         annotation_col = merged.sample.df,
         show_rownames = F,
         show_colnames = F,
         border_color = NA,
         main = "Expression Levels due to Correlations")

A <- cor(scale.efron(Xgs,50))
pheatmap(A,
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(A)), 0 - 0.01, length.out = 50),
                    seq(0, max(abs(A)), length.out = 50)),
         cluster_rows = F,
         cluster_cols = F,
         show_rownames = F,
         show_colnames = F,
         border_color = NA,
         annotation_row = merged.sample.df,
         annotation_col = merged.sample.df,
         main = "Sample Correlation")

A <- cor(t(scale.efron(Xgs,50)))
pheatmap(A,
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(A)), 0 - 0.01, length.out = 50),
                    seq(0, max(abs(A)), length.out = 50)),
         cluster_rows = F,
         cluster_cols = F,
         show_rownames = F,
         show_colnames = F,
         border_color = NA,
         annotation_row = module.gene.df,
         annotation_col = module.gene.df,
         main = "Gene Correlation")
```

## Combine covariance and mean-effect structures



```{r weights}

weight.Xgs <- 1
weight.outer <- 0
weight.batches <- 0
weight.groups <- 0
weight.modules <- 0
weight.modules_groups <- 1

Xfinal <- Xgs*weight.Xgs + z.outer*weight.outer + z.batches*weight.batches + z.groups*weight.groups + z.modules*weight.modules + z.modules_groups*weight.modules_groups

A <- scale.efron(Xfinal, niter = 50)
pheatmap(A,
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(A)), 0 - 0.01, length.out = 50),
                   seq(0, max(abs(A)), length.out = 50)),
         cluster_rows = T,
         cluster_cols = T,
         scale = "none",
         show_rownames = F,
         show_colnames = F,
         border_color = NA,
         annotation_row = module.gene.df,
         annotation_col = merged.sample.df,
         main = "Expression Levels due to Correlation and Bias")

```

## PCA Biplot

```{r}
g.group <- ggbiplot(prcomp(t(scale.efron(Xfinal,50))), groups = group.sample.df$group, ellipse = T)
g.batch <- ggbiplot(prcomp(t(scale.efron(Xfinal,50))), groups = batch.sample.df$batch, ellipse = T)

g.group
g.batch


```


